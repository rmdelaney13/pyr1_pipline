# ═══════════════════════════════════════════════════════════════════
# PYR1 ML DATASET GENERATION - MUTANT DOCKING CONFIG
# ═══════════════════════════════════════════════════════════════════
# This config supports the complete workflow:
#   SMILES → Conformers → Alignment Table → Threading → Docking
#
# Usage:
#   1. Generate conformers: python -m ligand_conformers --input <smiles>
#   2. Create table: python docking/scripts/create_table.py mutant_docking_example.conf
#   3. Thread variant: python scripts/thread_variant_to_pdb.py --template ... --signature ...
#   4. Dock: python docking/scripts/grade_conformers_mutant_docking.py mutant_docking_example.conf
# ═══════════════════════════════════════════════════════════════════

[DEFAULT]
# ═══════════════════════════════════════════════════════════════════
# PATH CONFIGURATION
# ═══════════════════════════════════════════════════════════════════

# Pipeline root directory
PIPE_ROOT = C:\Users\rmdel\OneDrive - UCB-O365\Whitehead Lab\pyr1_pipeline

# Campaign directory (unique per ML dataset)
CAMPAIGN_ROOT = C:\Users\rmdel\OneDrive - UCB-O365\Whitehead Lab\ml_datasets\pyr1_variant_screen_2026

# Scratch directory for docking outputs (can be large)
SCRATCH_ROOT = C:\scratch\pyr1_docking

# Template PDB for threading (WT PYR1 structure)
TEMPLATE_PDB = %(PIPE_ROOT)s\docking\ligand_alignment\files_for_PYR1_docking\3QN1_nolig_H2O.pdb

# ═══════════════════════════════════════════════════════════════════
# LIGAND CONFORMER PATHS
# ═══════════════════════════════════════════════════════════════════

# Directory containing conformer subdirectories (each ligand has its own folder)
PathToConformers = %(CAMPAIGN_ROOT)s\conformers_deprot

# CSV table with alignment atoms (output of create_table.py)
CSVFileName = %(CAMPAIGN_ROOT)s\ligands_alignment.csv

# Pickle file for cached table (optional)
PKLFileName = %(CAMPAIGN_ROOT)s\ligands_alignment.pkl

# ═══════════════════════════════════════════════════════════════════
# ALIGNMENT TARGET RESIDUE
# ═══════════════════════════════════════════════════════════════════

# Target residue for alignment (typically the binding pocket key residue)
# This is used to define alignment atom triplets in the CSV table
ChainLetter = A
ResidueNumber = 160  # PYR1 gate residue (adjust based on your template)

# Ligand residue number in conformer PDB (usually 1)
LigandResidueNumber = 1

# Auto-generate alignment atoms if CSV lacks them (slower, use DynamicAcceptorAlignment instead)
AutoGenerateAlignment = False

# ═══════════════════════════════════════════════════════════════════
# PARAMS FILES (for non-standard residues in template)
# ═══════════════════════════════════════════════════════════════════

# Space-separated list of Rosetta params files
# Example: A8T ligand in crystal structure template
ParamsList = %(PIPE_ROOT)s\docking\ligand_alignment\files_for_PYR1_docking\A8T.params


# ═══════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════
# UPSTREAM: CONFORMER TABLE GENERATION (create_table.py)
# ═══════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════

[create_table]

# Input ligand SDFs (glob pattern supported)
MoleculeSDFs = %(CAMPAIGN_ROOT)s\conformers_deprot\*\*_final.sdf

# Output table
CSVFileName = %(CSVFileName)s
PKLFileName = %(PKLFileName)s

# ═══════════════════════════════════════════════════════════════════
# DYNAMIC ACCEPTOR ALIGNMENT (auto-generate water H-bond alignment triplets)
# ═══════════════════════════════════════════════════════════════════

# Enable dynamic alignment (finds ligand acceptor atoms for water H-bonds)
DynamicAcceptorAlignment = True

# Max number of alignment triplets per molecule (prevents explosion)
MaxDynamicAlignments = 20

# Include reverse neighbor order for orientation flip (False to reduce output)
IncludeReverseNeighborOrder = False

# Target atom triplets in TEMPLATE ligand (water acceptor + 2 neighbors for orientation)
# Format: AcceptorAtom-Neighbor1-Neighbor2 (semicolon-separated)
# Example: O2 is ligand acceptor that H-bonds to water
TargetAtomTriplets = O2-C11-C9

# Acceptor detection mode:
#   auto = Use RDKit to auto-detect acceptors in ligand (recommended)
#   generic = Use common patterns (O, N atoms)
#   carbonyl = Only C=O groups
#   sulfonyl = Only S=O groups
#   hydroxyl_ether = Only O-C (not C=O)
AcceptorMode = auto

# Debug output for alignment generation (verbose logging)
DynamicAlignmentDebug = False

# Molecule naming (use IDs from SDF file)
UseMoleculeID = False
NoName = True


# ═══════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════
# DOWNSTREAM: MUTANT DOCKING (grade_conformers_mutant_docking.py)
# ═══════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════

[mutant_docking]

# ═══════════════════════════════════════════════════════════════════
# INPUT/OUTPUT
# ═══════════════════════════════════════════════════════════════════

# Pre-threaded mutant PDB (output of thread_variant_to_pdb.py)
# Example: mutant_59K_120A_160G.pdb means K59, A120, G160 substitutions
MutantPDB = %(CAMPAIGN_ROOT)s\threaded_variants\mutant_59K_120A_160G.pdb

# Output directory for docked poses and geometry CSV
OutputDir = %(SCRATCH_ROOT)s\docked_mutant_59K_120A_160G

# Output file naming prefix (auto-adds array index if array job)
OutputPrefix =

# Geometry diagnostics CSV name (auto-appends _arrayXXXX.csv for array tasks)
GeometryCSVName = hbond_geometry_summary.csv

# ═══════════════════════════════════════════════════════════════════
# PERTURBATION & SAMPLING
# ═══════════════════════════════════════════════════════════════════

# Jump number between protein and ligand chains (usually 2)
JumpNum = 2

# Random perturbation parameters (degrees and Angstroms)
Rotation = 25.0
Translation = 0.5

# Maximum perturbation attempts per conformer before giving up
# Higher = more thorough sampling, slower runtime
# ML dataset: 30-50 recommended for quality poses
MaxPerturbTries = 30

# ═══════════════════════════════════════════════════════════════════
# H-BOND GEOMETRY FILTER (CRITICAL FOR ML DATASET QUALITY)
# ═══════════════════════════════════════════════════════════════════

# Enable H-bond filtering (STRONGLY RECOMMENDED for ML)
EnableHBondGeometryFilter = True

# Use closest ligand acceptor to any water (vs. fixed alignment atom)
# True = dynamic (more robust), False = use alignment atom from CSV
UseClosestLigandAcceptor = True

# ─────────────────────────────────────────────────────────────────
# Distance Parameters (Angstroms)
# ─────────────────────────────────────────────────────────────────

# Ideal H-bond distance (ligand acceptor to water oxygen)
HBondDistanceIdeal = 2.8

# Buffer around ideal distance (creates accept range)
# Example: 2.8 ± 0.8 = accept 2.0-3.6 Å
HBondDistanceIdealBuffer = 0.8

# Optional: Explicit min/max overrides (uncomment to use)
# HBondDistanceMin = 2.0
# HBondDistanceMax = 3.6

# ─────────────────────────────────────────────────────────────────
# Angle Parameters (Degrees)
# ─────────────────────────────────────────────────────────────────

# Minimum donor angle (O-H...Acceptor)
# Ideal is 180° (linear), minimum ~120° for reasonable geometry
HBondDonorAngleMin = 120.0

# Ideal donor angle (for scoring)
HBondDonorAngleIdeal = 180.0

# Buffer for ideal donor window (if EnforceHBondIdealWindow = True)
HBondDonorAngleBuffer = 40.0

# Minimum acceptor angle (H-bond vector vs. ligand surface)
HBondAcceptorAngleMin = 90.0

# Ideal acceptor angle
HBondAcceptorAngleIdeal = 180.0

# Buffer for ideal acceptor window
HBondAcceptorAngleBuffer = 30.0

# Require acceptor angle to pass ideal window (usually False)
RequireAcceptorIdealWindow = False

# ─────────────────────────────────────────────────────────────────
# Quality Scoring
# ─────────────────────────────────────────────────────────────────

# Minimum composite quality score (0.0-1.0)
# Quality = distance_score × donor_score × acceptor_score
# 0.25 = reasonably permissive, 0.5 = strict
HBondQualityMin = 0.25

# Enforce ideal geometry windows during minimization (usually False)
EnforceHBondIdealWindow = False

# Enforce ideal geometry after packing (CRITICAL for ML quality)
# STRONGLY RECOMMENDED: True
EnforceFinalIdealGeometry = True

# ═══════════════════════════════════════════════════════════════════
# CONSTRAINT SETTINGS (guide minimization toward ideal H-bonds)
# ═══════════════════════════════════════════════════════════════════

# Weight for H-bond constraints during minimization
# Higher = stronger pull toward ideal geometry
# 4.0 = strong guidance, 1.0 = weak guidance
HBondConstraintWeight = 4.0

# Enable dynamic pull to nearest water oxygen
EnableDynamicWaterPullConstraint = True

# Constraint function parameters (harmonic potential)
HBondConstraintSD = 0.25  # Standard deviation (tighter = stronger)
HBondConstraintCaptureMax = 8.0  # Max distance to add constraint

# ═══════════════════════════════════════════════════════════════════
# SCORING & FILTERING
# ═══════════════════════════════════════════════════════════════════

# Score cutoff for accepting poses (Rosetta Energy Units)
# More negative = better binding
# Typical range: -200 to -500 REU
MaxScore = -300.0

# ═══════════════════════════════════════════════════════════════════
# CLUSTERING (RMSD-based deduplication)
# ═══════════════════════════════════════════════════════════════════

# Enable in-loop clustering (typically False for array jobs)
# If False, run cluster_docked_post_array.py after all tasks complete
EnablePoseClusteringInArrayTask = False

# RMSD cutoff for clustering (Angstroms, ligand heavy atoms)
# 0.75 = tight clustering, 1.5 = loose clustering
ClusterRMSDCutoff = 0.75

# Output directory for clustered results (post-array aggregation)
ClusteredOutputDir = %(SCRATCH_ROOT)s\docked_mutant_59K_120A_160G\clustered_final

# ═══════════════════════════════════════════════════════════════════
# SLURM ARRAY SUPPORT (parallel processing)
# ═══════════════════════════════════════════════════════════════════

# Total number of array tasks (1 = single job, >1 = parallel array)
# Example: 10 tasks splits 1000 conformers → 100 per task
ArrayTaskCount = 10

# ═══════════════════════════════════════════════════════════════════
# PERFORMANCE & DIAGNOSTICS
# ═══════════════════════════════════════════════════════════════════

# Log progress every N conformers
DebugEveryN = 10

# Warn if minimization exceeds threshold (seconds)
SlowMinimizationSeconds = 5.0

# Post-process: rename all water residues to TP3 for LigandMPNN compatibility
PostprocessRenameWaterSweep = True
